#include <stdio.h>
#include <string.h>

#define MAX_STACK_SIZE 100

typedef int element ;

typedef struct {
    element data[MAX_STACK_SIZE] ;
    int top ;
} StackType ;

void init_stack(StackType *s) {
    s->top = -1 ;
}

int is_empty(StackType *s) {
    return (s->top == -1) ;
}

int is_full(StackType *s) {
    return (s->top == (MAX_STACK_SIZE - 1)) ;
}

void push(StackType *s, element item) {
    if (is_full(s)) {
        fprintf(stderr, "Stack Full") ;
        return ;
    }
    else {
        s->data[++(s->top)] = item ;
    }
}

element pop(StackType *s) {
    if (is_empty(s)) {
        fprintf(stderr, "Stack Empty") ;
        return -1 ;
    }
    else {
        return (s->data[(s->top)--]) ;
    }
}

element peek(StackType *s) {
    if(is_empty(s)) {
        fprintf(stderr, "Stack Empty") ;
        return -1 ;
    }
    else {
        return(s->data[s->top]) ;
    }
}

int prec(char op) {
    switch(op) {
        case '(': case ')': return 0 ;
        case '+': case '-': return 1 ;
        case '*': case '/': return 2 ;
    }
    return -1 ;
}

void infix_to_postfix(char exp[], char postfix[]) { // 중위식표기법 >> 후위식표기법
    int i = 0 ;
    char ch, top_op ;
    int len = strlen(exp) ;
    StackType s ;
    init_stack(&s) ;

    int postfix_index = 0 ;

    for(i=0; i<len; i++) {
        ch = exp[i] ;
        switch (ch) {
            case '+': case '-': case '*': case '/':   //연산자
                while(!is_empty(&s) && (prec(ch)) <= (prec(peek(&s)))) { //stack에 있는 연산자의 우선순위가 크거나 같으면 출력
                    postfix[postfix_index++] = pop(&s) ;
                }
                push(&s, ch) ;
                break ;
            case '(': push(&s, ch) ; //왼쪽괄호
                break ;
            case ')': top_op = pop(&s) ; //오른쪽괄호
                while(top_op != '(') { //왼쪽괄호를 만날 때 까지 출력
                    postfix[postfix_index++] = top_op ;
                    top_op = pop(&s) ;
                }
            break ; //피연산자
            default:
                while(ch >= '0' && ch <= '9') {
                    postfix[postfix_index++] = ch ;
                    ch = exp[++i] ;
                }
                postfix[postfix_index++] = ' ' ;
                i-- ;
                break ;
        }
    }
    while(!is_empty(&s)) { //stack에 저장된 연산자들 출력
        postfix[postfix_index++] = pop(&s) ;
    }
    postfix[postfix_index++] = '\0' ;
}

int eval(char exp[]) {
    int op1, op2, i = 0 ;
    int len = strlen(exp) ;
    char ch, top_op ;
    StackType s ;
    init_stack(&s) ;

    for (i=0; i<len; i++) {
        ch = exp[i] ;
        if (ch >= '0' && ch <= '9') {
            push(&s, ch - '0') ;
        }
        else if(ch == '+' || ch == '-'|| ch == '*'|| ch == '/') {
            op2 = pop(&s) ;
            op1 = pop(&s) ;
            switch (ch) {
                case '+': push(&s, op1 + op2); break ;
                case '-': push(&s, op1 - op2); break ;
                case '*': push(&s, op1 * op2); break ;
                case '/':
                    if(op2 == 0) {
                        fprintf(stderr, "Division by zero error\n") ;
                        return -1 ;
                    }
                    else {
                        push(&s, op1 / op2) ;
                        break ;
                    }
                default:
                    fprintf(stderr, "Invaild Character\n") ;
            }
        }
        else {
            fprintf(stderr, "Invaild Character\n") ;
            return -1 ;
        }
    }
    return pop(&s) ;
}

int main() {
    int result ;
    char user_enter[MAX_STACK_SIZE] ;
    char postfix[MAX_STACK_SIZE] ;

    printf("Enter an infix expression : ") ;
    scanf("%[^\n]", user_enter) ;

    infix_to_postfix(user_enter, postfix) ;
    printf("Outfix expression : %s\n", postfix) ;

    result = eval(postfix) ;
    printf("Result : %d\n", result) ;
    
    return 0 ;
}